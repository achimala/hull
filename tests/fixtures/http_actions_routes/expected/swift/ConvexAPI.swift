// swift-format-ignore-file
// This file is @generated by hull. DO NOT EDIT.
import Foundation
@preconcurrency import ConvexMobile

fileprivate func encodeConvexArgs(_ args: [String: ConvexEncodable?]) throws -> [String: String] {
    try args.mapValues { value in
        try value?.convexEncode() ?? "null"
    }
}

fileprivate func convexCall<T: Decodable>(
    client: MobileConvexClient,
    path: String,
    args: [String: ConvexEncodable?],
    remoteCall: (String, [String: String]) async throws -> String
) async throws -> T {
    let encodedArgs = try encodeConvexArgs(args)
    let rawResult = try await remoteCall(path, encodedArgs)
    return try JSONDecoder().decode(T.self, from: Data(rawResult.utf8))
}

fileprivate actor ConvexSubscriptionState {
    private var handle: SubscriptionHandle?
    private var terminated = false

    func setHandle(_ handle: SubscriptionHandle) {
        if terminated {
            handle.cancel()
            return
        }
        self.handle = handle
    }

    func terminate() {
        terminated = true
        handle?.cancel()
        handle = nil
    }
}

fileprivate struct ConvexSubscriptionError: LocalizedError {
    let message: String
    let value: String?

    var errorDescription: String? { message }
}

fileprivate final class ConvexAsyncQuerySubscriber<T: Decodable>: QuerySubscriber {
    private let decoder: JSONDecoder
    private let continuation: AsyncThrowingStream<T, Error>.Continuation

    init(decoder: JSONDecoder, continuation: AsyncThrowingStream<T, Error>.Continuation) {
        self.decoder = decoder
        self.continuation = continuation
    }

    func onError(message: String, value: String?) {
        continuation.finish(throwing: ConvexSubscriptionError(message: message, value: value))
    }

    func onUpdate(value: String) {
        do {
            let decoded = try decoder.decode(T.self, from: Data(value.utf8))
            continuation.yield(decoded)
        } catch {
            continuation.finish(throwing: error)
        }
    }
}

fileprivate func convexSubscribe<T: Decodable>(
    client: MobileConvexClient,
    path: String,
    args: [String: ConvexEncodable?],
    yielding: T.Type
) -> AsyncThrowingStream<T, Error> {
    AsyncThrowingStream { continuation in
        let state = ConvexSubscriptionState()
        continuation.onTermination = { _ in
            Task { await state.terminate() }
        }
        let subscriber = ConvexAsyncQuerySubscriber(decoder: JSONDecoder(), continuation: continuation)
        Task {
            do {
                let encodedArgs = try encodeConvexArgs(args)
                let handle = try await client.subscribe(name: path, args: encodedArgs, subscriber: subscriber)
                await state.setHandle(handle)
            } catch {
                continuation.finish(throwing: error)
            }
        }
    }
}

enum ConvexHTTPError: LocalizedError {
    case invalidSiteURL(String)

    var errorDescription: String? {
        switch self {
        case .invalidSiteURL(let value):
            return "Invalid site URL: \(value)"
        }
    }
}

fileprivate func convexHTTPRouteURL(siteURL: String, routePath: String) throws -> URL {
    let trimmed = siteURL.trimmingCharacters(in: .whitespacesAndNewlines)
    guard let base = URL(string: trimmed) else {
        throw ConvexHTTPError.invalidSiteURL(trimmed)
    }

    var url = base
    for part in routePath.split(separator: "/") {
        let component = String(part)
        guard !component.isEmpty else { continue }
        url.appendPathComponent(component)
    }

    return url
}

enum ConvexQueries {
}

enum ConvexMutations {
}

enum ConvexActions {
}

enum ConvexHTTPActions {
    static let aiCorrectStreamMethod: String = "POST"
    static let aiCorrectStreamPath: String = "/api/ai/correct-stream"

    static func aiCorrectStreamURL(
        siteURL: String
    ) throws -> URL {
        try convexHTTPRouteURL(siteURL: siteURL, routePath: aiCorrectStreamPath)
    }

    static func aiCorrectStreamRequest(
        siteURL: String,
        accessToken: String? = nil,
        body: Data? = nil,
        contentType: String = "application/json"
    ) throws -> URLRequest {
        let url = try aiCorrectStreamURL(siteURL: siteURL)
        var request = URLRequest(url: url)
        request.httpMethod = aiCorrectStreamMethod
        if let token = accessToken?.trimmingCharacters(in: .whitespacesAndNewlines), !token.isEmpty {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        if let body {
            request.httpBody = body
            request.setValue(contentType, forHTTPHeaderField: "Content-Type")
        }
        return request
    }

    static let billingStripeWebhookMethod: String = "POST"
    static let billingStripeWebhookPath: String = "/api/stripe/webhook"

    static func billingStripeWebhookURL(
        siteURL: String
    ) throws -> URL {
        try convexHTTPRouteURL(siteURL: siteURL, routePath: billingStripeWebhookPath)
    }

    static func billingStripeWebhookRequest(
        siteURL: String,
        accessToken: String? = nil,
        body: Data? = nil,
        contentType: String = "application/json"
    ) throws -> URLRequest {
        let url = try billingStripeWebhookURL(siteURL: siteURL)
        var request = URLRequest(url: url)
        request.httpMethod = billingStripeWebhookMethod
        if let token = accessToken?.trimmingCharacters(in: .whitespacesAndNewlines), !token.isEmpty {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        if let body {
            request.httpBody = body
            request.setValue(contentType, forHTTPHeaderField: "Content-Type")
        }
        return request
    }

}
