// This file is @generated by hull. DO NOT EDIT.
#![allow(non_snake_case)]
#![allow(clippy::disallowed_types)]
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;
use std::collections::{BTreeMap, HashMap};
use crate::convex::ConvexValue;

#[derive(Debug, Clone)]
pub struct ConvexTypeError {
    message: String,
}
impl ConvexTypeError {
    pub fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
        }
    }
}
impl std::fmt::Display for ConvexTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}
impl std::error::Error for ConvexTypeError {}

pub trait ConvexEncode {
    fn to_convex_value(&self) -> ConvexValue;
}

mod sealed {
    pub trait Sealed {}
}

pub trait ConvexArgs: sealed::Sealed + ConvexEncode {}
impl<T> ConvexArgs for T
where
    T: sealed::Sealed + ConvexEncode,
{}

pub trait JsonValidate: Sized {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError>;
    fn parse_json(value: &JsonValue) -> Result<Self, ConvexTypeError>
    where
        Self: for<'de> Deserialize<'de>,
    {
        Self::validate_json(value)?;
        serde_json::from_value(value.clone())
            .map_err(|err| ConvexTypeError::new(err.to_string()))
    }
}

fn json_value_to_convex(value: &JsonValue) -> ConvexValue {
    match value {
        JsonValue::Null => ConvexValue::Null,
        JsonValue::Bool(value) => ConvexValue::Bool(*value),
        JsonValue::Number(value) => ConvexValue::Float(value.as_f64().unwrap_or(0.0)),
        JsonValue::String(value) => ConvexValue::String(value.clone()),
        JsonValue::Array(values) => {
            ConvexValue::Array(values.iter().map(json_value_to_convex).collect())
        }
        JsonValue::Object(values) => ConvexValue::Object(
            values
                .iter()
                .map(|(key, value)| (key.clone(), json_value_to_convex(value)))
                .collect(),
        ),
    }
}

impl ConvexEncode for String {
    fn to_convex_value(&self) -> ConvexValue {
        ConvexValue::String(self.clone())
    }
}
impl ConvexEncode for bool {
    fn to_convex_value(&self) -> ConvexValue {
        ConvexValue::Bool(*self)
    }
}
impl ConvexEncode for f64 {
    fn to_convex_value(&self) -> ConvexValue {
        ConvexValue::Float(*self)
    }
}
impl ConvexEncode for i64 {
    fn to_convex_value(&self) -> ConvexValue {
        ConvexValue::Int(*self)
    }
}
impl ConvexEncode for () {
    fn to_convex_value(&self) -> ConvexValue {
        ConvexValue::Null
    }
}
impl ConvexEncode for JsonValue {
    fn to_convex_value(&self) -> ConvexValue {
        json_value_to_convex(self)
    }
}
impl<T> ConvexEncode for Option<T>
where
    T: ConvexEncode,
{
    fn to_convex_value(&self) -> ConvexValue {
        match self {
            Some(value) => value.to_convex_value(),
            None => ConvexValue::Null,
        }
    }
}
impl<T> ConvexEncode for Vec<T>
where
    T: ConvexEncode,
{
    fn to_convex_value(&self) -> ConvexValue {
        ConvexValue::Array(self.iter().map(ConvexEncode::to_convex_value).collect())
    }
}
impl<T> ConvexEncode for HashMap<String, T>
where
    T: ConvexEncode,
{
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        for (key, value) in self {
            map.insert(key.clone(), value.to_convex_value());
        }
        ConvexValue::Object(map)
    }
}

impl JsonValidate for String {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        if value.is_string() {
            Ok(())
        } else {
            Err(ConvexTypeError::new("expected string"))
        }
    }
}
impl JsonValidate for bool {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        if value.is_boolean() {
            Ok(())
        } else {
            Err(ConvexTypeError::new("expected bool"))
        }
    }
}
impl JsonValidate for f64 {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        if value.is_number() {
            Ok(())
        } else {
            Err(ConvexTypeError::new("expected number"))
        }
    }
}
impl JsonValidate for i64 {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        if value.as_i64().is_some() {
            Ok(())
        } else {
            Err(ConvexTypeError::new("expected int64"))
        }
    }
}
impl JsonValidate for () {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        if value.is_null() {
            Ok(())
        } else {
            Err(ConvexTypeError::new("expected null"))
        }
    }
}
impl JsonValidate for JsonValue {
    fn validate_json(_value: &JsonValue) -> Result<(), ConvexTypeError> {
        Ok(())
    }
}
impl<T> JsonValidate for Option<T>
where
    T: JsonValidate,
{
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        if value.is_null() {
            Ok(())
        } else {
            T::validate_json(value)
        }
    }
}
impl<T> JsonValidate for Vec<T>
where
    T: JsonValidate,
{
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let array = value
            .as_array()
            .ok_or_else(|| ConvexTypeError::new("expected array"))?;
        for item in array {
            T::validate_json(item)?;
        }
        Ok(())
    }
}
impl<T> JsonValidate for HashMap<String, T>
where
    T: JsonValidate,
{
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for item in object.values() {
            T::validate_json(item)?;
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ThingsCreateArgsItem {
    pub count: f64,
    pub title: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ThingsCreateArgs {
    pub item: ThingsCreateArgsItem,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ThingsInspectArgs {
    pub id: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ThingsListArgs {
    pub cursor: Option<String>,
    #[serde(rename = "includeGone")]
    pub include_gone: Option<bool>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum PrimitiveThingStatus {
    #[serde(rename = "ok")]
    Ok,
    #[serde(rename = "bad")]
    Bad,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PrimitiveThing {
    pub anything: JsonValue,
    pub count: f64,
    pub enabled: bool,
    pub gone: (),
    #[serde(rename = "maybeNote")]
    pub maybe_note: Option<String>,
    #[serde(rename = "maybeRef")]
    pub maybe_ref: Option<String>,
    pub metrics: HashMap<String, f64>,
    pub ratio: f64,
    pub role: String,
    pub score: f64,
    pub status: PrimitiveThingStatus,
    pub summary: Option<String>,
    pub tags: Vec<String>,
    pub title: String,
    pub visits: i64,
}

pub type ThingsCreateReturn = String;
pub type ThingsInspectReturn = Option<Thing>;
pub type ThingsListReturn = Vec<Thing>;
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum ThingStatus {
    #[serde(rename = "ok")]
    Ok,
    #[serde(rename = "bad")]
    Bad,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Thing {
    pub _id: String,
    pub anything: JsonValue,
    pub count: f64,
    pub enabled: bool,
    pub gone: (),
    #[serde(rename = "maybeNote")]
    pub maybe_note: Option<String>,
    #[serde(rename = "maybeRef")]
    pub maybe_ref: Option<String>,
    pub metrics: HashMap<String, f64>,
    pub ratio: f64,
    pub role: String,
    pub score: f64,
    pub status: ThingStatus,
    pub summary: Option<String>,
    pub tags: Vec<String>,
    pub title: String,
    pub visits: i64,
}

impl ConvexEncode for ThingsCreateArgsItem {
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        map.insert("count".to_string(), self.count.to_convex_value());
        map.insert("title".to_string(), self.title.to_convex_value());
        ConvexValue::Object(map)
    }
}

impl ConvexEncode for ThingsCreateArgs {
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        map.insert("item".to_string(), self.item.to_convex_value());
        ConvexValue::Object(map)
    }
}

impl ConvexEncode for ThingsInspectArgs {
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        map.insert("id".to_string(), self.id.to_convex_value());
        ConvexValue::Object(map)
    }
}

impl ConvexEncode for ThingsListArgs {
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        if let Some(value) = &self.cursor {
            map.insert("cursor".to_string(), value.to_convex_value());
        }
        if let Some(value) = &self.include_gone {
            map.insert("includeGone".to_string(), value.to_convex_value());
        }
        ConvexValue::Object(map)
    }
}

impl ConvexEncode for PrimitiveThingStatus {
    fn to_convex_value(&self) -> ConvexValue {
        match self {
            PrimitiveThingStatus::Ok => ConvexValue::String("ok".to_string()),
            PrimitiveThingStatus::Bad => ConvexValue::String("bad".to_string()),
        }
    }
}

impl ConvexEncode for PrimitiveThing {
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        map.insert("anything".to_string(), self.anything.to_convex_value());
        map.insert("count".to_string(), self.count.to_convex_value());
        map.insert("enabled".to_string(), self.enabled.to_convex_value());
        map.insert("gone".to_string(), self.gone.to_convex_value());
        if let Some(value) = &self.maybe_note {
            map.insert("maybeNote".to_string(), value.to_convex_value());
        }
        if let Some(value) = &self.maybe_ref {
            map.insert("maybeRef".to_string(), value.to_convex_value());
        }
        map.insert("metrics".to_string(), self.metrics.to_convex_value());
        map.insert("ratio".to_string(), self.ratio.to_convex_value());
        map.insert("role".to_string(), self.role.to_convex_value());
        map.insert("score".to_string(), self.score.to_convex_value());
        map.insert("status".to_string(), self.status.to_convex_value());
        match &self.summary {
            Some(value) => { map.insert("summary".to_string(), value.to_convex_value()); }
            None => { map.insert("summary".to_string(), ConvexValue::Null); }
        }
        map.insert("tags".to_string(), self.tags.to_convex_value());
        map.insert("title".to_string(), self.title.to_convex_value());
        map.insert("visits".to_string(), self.visits.to_convex_value());
        ConvexValue::Object(map)
    }
}

impl ConvexEncode for ThingStatus {
    fn to_convex_value(&self) -> ConvexValue {
        match self {
            ThingStatus::Ok => ConvexValue::String("ok".to_string()),
            ThingStatus::Bad => ConvexValue::String("bad".to_string()),
        }
    }
}

impl ConvexEncode for Thing {
    fn to_convex_value(&self) -> ConvexValue {
        let mut map = BTreeMap::new();
        map.insert("_id".to_string(), self._id.to_convex_value());
        map.insert("anything".to_string(), self.anything.to_convex_value());
        map.insert("count".to_string(), self.count.to_convex_value());
        map.insert("enabled".to_string(), self.enabled.to_convex_value());
        map.insert("gone".to_string(), self.gone.to_convex_value());
        if let Some(value) = &self.maybe_note {
            map.insert("maybeNote".to_string(), value.to_convex_value());
        }
        if let Some(value) = &self.maybe_ref {
            map.insert("maybeRef".to_string(), value.to_convex_value());
        }
        map.insert("metrics".to_string(), self.metrics.to_convex_value());
        map.insert("ratio".to_string(), self.ratio.to_convex_value());
        map.insert("role".to_string(), self.role.to_convex_value());
        map.insert("score".to_string(), self.score.to_convex_value());
        map.insert("status".to_string(), self.status.to_convex_value());
        match &self.summary {
            Some(value) => { map.insert("summary".to_string(), value.to_convex_value()); }
            None => { map.insert("summary".to_string(), ConvexValue::Null); }
        }
        map.insert("tags".to_string(), self.tags.to_convex_value());
        map.insert("title".to_string(), self.title.to_convex_value());
        map.insert("visits".to_string(), self.visits.to_convex_value());
        ConvexValue::Object(map)
    }
}

impl sealed::Sealed for ThingsListArgs {}

impl sealed::Sealed for ThingsCreateArgs {}

impl sealed::Sealed for ThingsInspectArgs {}

impl JsonValidate for ThingsCreateArgsItem {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for key in object.keys() {
            match key.as_str() {
                "count" => {}
                "title" => {}
                _ => return Err(ConvexTypeError::new(format!("unknown field: {}", key))),
            }
        }
        if let Some(field_value) = object.get("count") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: count"));
        }
        if let Some(field_value) = object.get("title") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: title"));
        }
        Ok(())
    }
}

impl JsonValidate for ThingsCreateArgs {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for key in object.keys() {
            match key.as_str() {
                "item" => {}
                _ => return Err(ConvexTypeError::new(format!("unknown field: {}", key))),
            }
        }
        if let Some(field_value) = object.get("item") {
            <ThingsCreateArgsItem as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: item"));
        }
        Ok(())
    }
}

impl JsonValidate for ThingsInspectArgs {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for key in object.keys() {
            match key.as_str() {
                "id" => {}
                _ => return Err(ConvexTypeError::new(format!("unknown field: {}", key))),
            }
        }
        if let Some(field_value) = object.get("id") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: id"));
        }
        Ok(())
    }
}

impl JsonValidate for ThingsListArgs {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for key in object.keys() {
            match key.as_str() {
                "cursor" => {}
                "includeGone" => {}
                _ => return Err(ConvexTypeError::new(format!("unknown field: {}", key))),
            }
        }
        if let Some(field_value) = object.get("cursor") {
            if field_value.is_null() {
                return Err(ConvexTypeError::new("optional field 'cursor' must be omitted, not null"));
            }
            <String as JsonValidate>::validate_json(field_value)?;
        }
        if let Some(field_value) = object.get("includeGone") {
            if field_value.is_null() {
                return Err(ConvexTypeError::new("optional field 'includeGone' must be omitted, not null"));
            }
            <bool as JsonValidate>::validate_json(field_value)?;
        }
        Ok(())
    }
}

impl JsonValidate for PrimitiveThingStatus {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let value = value.as_str().ok_or_else(|| ConvexTypeError::new("expected string"))?;
        match value {
            "ok" => Ok(()),
            "bad" => Ok(()),
            _ => Err(ConvexTypeError::new("invalid enum value")),
        }
    }
}

impl JsonValidate for PrimitiveThing {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for key in object.keys() {
            match key.as_str() {
                "anything" => {}
                "count" => {}
                "enabled" => {}
                "gone" => {}
                "maybeNote" => {}
                "maybeRef" => {}
                "metrics" => {}
                "ratio" => {}
                "role" => {}
                "score" => {}
                "status" => {}
                "summary" => {}
                "tags" => {}
                "title" => {}
                "visits" => {}
                _ => return Err(ConvexTypeError::new(format!("unknown field: {}", key))),
            }
        }
        if let Some(field_value) = object.get("anything") {
            <JsonValue as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: anything"));
        }
        if let Some(field_value) = object.get("count") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: count"));
        }
        if let Some(field_value) = object.get("enabled") {
            <bool as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: enabled"));
        }
        if let Some(field_value) = object.get("gone") {
            <() as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: gone"));
        }
        if let Some(field_value) = object.get("maybeNote") {
            if field_value.is_null() {
                return Err(ConvexTypeError::new("optional field 'maybeNote' must be omitted, not null"));
            }
            <String as JsonValidate>::validate_json(field_value)?;
        }
        if let Some(field_value) = object.get("maybeRef") {
            if field_value.is_null() {
                return Err(ConvexTypeError::new("optional field 'maybeRef' must be omitted, not null"));
            }
            <String as JsonValidate>::validate_json(field_value)?;
        }
        if let Some(field_value) = object.get("metrics") {
            <HashMap<String, f64> as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: metrics"));
        }
        if let Some(field_value) = object.get("ratio") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: ratio"));
        }
        if let Some(field_value) = object.get("role") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: role"));
        }
        if let Some(field_value) = object.get("score") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: score"));
        }
        if let Some(field_value) = object.get("status") {
            <PrimitiveThingStatus as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: status"));
        }
        if let Some(field_value) = object.get("summary") {
            if !field_value.is_null() {
                <String as JsonValidate>::validate_json(field_value)?;
            }
        } else {
            return Err(ConvexTypeError::new("missing required field: summary"));
        }
        if let Some(field_value) = object.get("tags") {
            <Vec<String> as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: tags"));
        }
        if let Some(field_value) = object.get("title") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: title"));
        }
        if let Some(field_value) = object.get("visits") {
            <i64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: visits"));
        }
        Ok(())
    }
}

impl JsonValidate for ThingStatus {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let value = value.as_str().ok_or_else(|| ConvexTypeError::new("expected string"))?;
        match value {
            "ok" => Ok(()),
            "bad" => Ok(()),
            _ => Err(ConvexTypeError::new("invalid enum value")),
        }
    }
}

impl JsonValidate for Thing {
    fn validate_json(value: &JsonValue) -> Result<(), ConvexTypeError> {
        let object = value
            .as_object()
            .ok_or_else(|| ConvexTypeError::new("expected object"))?;
        for key in object.keys() {
            match key.as_str() {
                "_id" => {}
                "anything" => {}
                "count" => {}
                "enabled" => {}
                "gone" => {}
                "maybeNote" => {}
                "maybeRef" => {}
                "metrics" => {}
                "ratio" => {}
                "role" => {}
                "score" => {}
                "status" => {}
                "summary" => {}
                "tags" => {}
                "title" => {}
                "visits" => {}
                _ => return Err(ConvexTypeError::new(format!("unknown field: {}", key))),
            }
        }
        if let Some(field_value) = object.get("_id") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: _id"));
        }
        if let Some(field_value) = object.get("anything") {
            <JsonValue as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: anything"));
        }
        if let Some(field_value) = object.get("count") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: count"));
        }
        if let Some(field_value) = object.get("enabled") {
            <bool as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: enabled"));
        }
        if let Some(field_value) = object.get("gone") {
            <() as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: gone"));
        }
        if let Some(field_value) = object.get("maybeNote") {
            if field_value.is_null() {
                return Err(ConvexTypeError::new("optional field 'maybeNote' must be omitted, not null"));
            }
            <String as JsonValidate>::validate_json(field_value)?;
        }
        if let Some(field_value) = object.get("maybeRef") {
            if field_value.is_null() {
                return Err(ConvexTypeError::new("optional field 'maybeRef' must be omitted, not null"));
            }
            <String as JsonValidate>::validate_json(field_value)?;
        }
        if let Some(field_value) = object.get("metrics") {
            <HashMap<String, f64> as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: metrics"));
        }
        if let Some(field_value) = object.get("ratio") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: ratio"));
        }
        if let Some(field_value) = object.get("role") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: role"));
        }
        if let Some(field_value) = object.get("score") {
            <f64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: score"));
        }
        if let Some(field_value) = object.get("status") {
            <ThingStatus as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: status"));
        }
        if let Some(field_value) = object.get("summary") {
            if !field_value.is_null() {
                <String as JsonValidate>::validate_json(field_value)?;
            }
        } else {
            return Err(ConvexTypeError::new("missing required field: summary"));
        }
        if let Some(field_value) = object.get("tags") {
            <Vec<String> as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: tags"));
        }
        if let Some(field_value) = object.get("title") {
            <String as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: title"));
        }
        if let Some(field_value) = object.get("visits") {
            <i64 as JsonValidate>::validate_json(field_value)?;
        } else {
            return Err(ConvexTypeError::new("missing required field: visits"));
        }
        Ok(())
    }
}

